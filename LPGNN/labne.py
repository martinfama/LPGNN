import torch as th
import torch_geometric as pyg

import igraph
import networkx as nx
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import scipy
import scipy.optimize
import pandas as pd
import copy
import time
from .metrics import *
from .utils import infer_gamma

#generates the Laplacian Based Network Embedding for a given Network
def generateLaBNE(data:pyg.data.Data, eigenvector_k=3):
    """ Given a graph, returns the LaBNE embedding as described in [1].

        [1] Alanis-Lobato, G., Mier, P. & Andrade-Navarro, M. Efficient embedding of complex networks to hyperbolic space via their Laplacian. Sci Rep 6, 30108 (2016). https://doi.org/10.1038/srep30108

    Args:
        data (pyg.data.Data): The graph to embed.
        eigenvector_k (int, optional): The dimensionality requested of the embedding. Defaults to 3, which is in fact the 2-dimensional case
                                       since the first eigenvector has a null eigenvalue associated.

    Returns:
        _type_: _description_
    """    

    N = data.num_nodes
    degrees = pyg.utils.degree(data.edge_index[0])
    m = int(degrees.mean()/2)
    gamma = infer_gamma(data).power_law.alpha

    #get Laplacian matrix of the graph (L = D - A). We pass it to a sparse matrix type supported by SciPy
    #so that we can use scipy's sparse linear algebra tools
    L = pyg.utils.get_laplacian(data.edge_index)
    L = pyg.utils.to_scipy_sparse_matrix(L[0], L[1])
    #L = scipy.sparse.csr_matrix(L)
    #L = L.asfptype()
    #the tol parameter of scipy.sparse.lingalg() is to give an error tolerance. for smaller networks, convergence seems to be
    #guaranteed with high precision. for larger networks, convergence maybe a problem, so an error tolerance is given. criteria
    #the same as in Alanis-Lobato's NetHypGeom library
    if N < 10000:
        try:
            eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L, k=eigenvector_k, which='LM', sigma=0, return_eigenvectors=True)
        except(RuntimeError):
            Levenberg_c = np.zeros(np.shape(L))
            np.fill_diagonal(Levenberg_c, 0.01)
            Levenberg_c = scipy.sparse.coo_matrix(Levenberg_c)
            eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L+Levenberg_c, k=eigenvector_k, which='LM', sigma=0, return_eigenvectors=True)
        #eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L, k=eigenvector_k, which='SM', return_eigenvectors=True)
    else:        
        try:
            eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L, k=eigenvector_k, which='LM', sigma=0, return_eigenvectors=True, tol=1E-7, maxiter=5000)
        except(RuntimeError):
            Levenberg_c = np.zeros(np.shape(L))
            np.fill_diagonal(Levenberg_c, 0.01)
            Levenberg_c = scipy.sparse.coo_matrix(Levenberg_c)
            eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L+Levenberg_c, k=eigenvector_k, which='LM', sigma=0, return_eigenvectors=True, tol=1E-7, maxiter=5000)

        #eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L, k=eigenvector_k, which='SM', return_eigenvectors=True, tol=1E-7)
    eigenvectors = np.transpose(eigenvectors)
    x, y = eigenvectors[1].real, eigenvectors[2].real
    return x,y
    # labne_graph = copy.deepcopy(network.graph)
    
    # #sort original indexes of graph by degree. 
    # #sorted_o_i = np.transpose(sorted(np.transpose([network.graph.vs['o_i'], network.graph.degree()]), key= lambda x: x[1], reverse=True))[0]
    # #labne_graph.vs['o_i'] = sorted_o_i
    # labne_graph.vs['degree_sorted_index'] = np.argsort(graph.degree())[::-1]

    # for t in range(N):
    #     r_t = np.log(t+1)
    #     labne_graph.vs[labne_graph.vs[t]['degree_sorted_index']]['r'] = 2*beta*r_t + 2*(1-beta)*np.log(N)
    #     #labne_graph.vs[t]['r'] = 2*beta*r_t + 2*(1-beta)*np.log(N)
    #     labne_graph.vs[t]['theta'] = np.arctan2(y[t], x[t])
    #     if labne_graph.vs[t]['theta'] < 0:
    #         labne_graph.vs[t]['theta'] = labne_graph.vs[t]['theta']+2*np.pi

    # #assign a rainbow palette based on the angular coordinate
    # #if graph was generated by PS Method apply the original colors for comparison
    # rainbow_palette = igraph.RainbowPalette(n=N)
    # try:
    #     if network.is_PS_generated:
    #         for i in range(N):
    #             labne_graph.vs[i]['color'] = rainbow_palette.get(int(graph.vs[i]['theta']/(2*np.pi)*N))
    #     else:
    #         raise Exception()
    # except:
    #     for i in range(N):
    #         labne_graph.vs[i]['color'] = rainbow_palette.get(int(labne_graph.vs[i]['theta']/(2*np.pi)*(N-1)))

    # #give the igraph Graph x and y coordinates, so as to be able to plot it
    # #and show the hyperbolic structure
    # #labne_graph.vs['x'] = labne_graph.vs['r']*np.cos(labne_graph.vs['theta'])
    # #labne_graph.vs['y'] = labne_graph.vs['r']*np.sin(labne_graph.vs['theta'])
    # labne_graph.vs['y'] = eigenvectors[1]
    # labne_graph.vs['x'] = eigenvectors[2]
    # labne_graph.vs['size'] = node_size_by_degree(graph=labne_graph, m=1)

    # #also return a matplotlib scatter plot with the coordinates given by the embedding
    # #leaving this aside for a while, igraph already works well enough
    # """
    # if scatterPlot:
    #     fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(16,8))

    #     ax1.grid(alpha=0.5)
    #     ax2.grid(alpha=0.5)

    #     if plotEdges:
    #         for i in range(N):
    #             for j in range(i, N):
    #                 if graph.are_connected(i, j):
    #                     ax1.plot([graph.vs[i]['r']*np.cos(graph.vs[i]['theta']), graph.vs[j]['r']*np.cos(graph.vs[j]['theta'])], 
    #                              [graph.vs[i]['r']*np.sin(graph.vs[i]['theta']), graph.vs[j]['r']*np.sin(graph.vs[j]['theta'])],
    #                             linewidth=0.2,
    #                             c='black', zorder=-1)
    #                     ax2.plot([labne_graph.vs[i]['r']*np.cos(labne_graph.vs[i]['theta']), labne_graph.vs[j]['r']*np.cos(labne_graph.vs[j]['theta'])], 
    #                              [labne_graph.vs[i]['r']*np.sin(labne_graph.vs[i]['theta']), labne_graph.vs[j]['r']*np.sin(labne_graph.vs[j]['theta'])],
    #                             linewidth=0.2,
    #                             c='black', zorder=-1)

    #     ax1.scatter(graph.vs['r']*np.cos(graph.vs['theta']), graph.vs['r']*np.sin(graph.vs['theta']),
    #                s=16, c=graph.vs['theta'], cmap='rainbow', zorder=0)

    #     degree_sorted, theta_sorted = zip(*sorted(zip(graph.vs.degree(), graph.vs['theta'])))
    #     degree_sorted = degree_sorted[::-1]
    #     theta_sorted  = theta_sorted[::-1]

    #     ax2.scatter(labne_graph.vs['r']*np.cos(labne_graph.vs['theta']), labne_graph.vs['r']*np.sin(labne_graph.vs['theta']),
    #                 s=16, c=labne_graph.vs['theta'], cmap='rainbow', zorder=0, marker='^')
        
    #     #return labne_graph, labne_nodes, fig, ax1, ax2
    #     return labne_graph, fig, ax1, ax2
    # """
    # return labne_graph